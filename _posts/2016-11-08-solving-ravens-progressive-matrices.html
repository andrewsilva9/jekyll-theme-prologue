---
layout: post
title: Solving Raven's Progressive Matrices Algorithmically
date: '2016-11-08T13:28:00.000-05:00'
author: Andrew Silva
tags: 
modified_time: '2016-11-09T09:27:20.983-05:00'
blogger_id: tag:blogger.com,1999:blog-8622339093465720931.post-4098663628920565665
blogger_orig_url: http://www.andrew-silva.com/2016/11/solving-ravens-progressive-matrices.html
---

Raven's Progressive Matrices are a fun and interesting problem used to demonstrate critical thinking and problem solving capabilities. The format of the problems is a series of images that represent some pattern, where the test-taker must choose the image that best completes the pattern from a list of possible choices. For instance, here is a Raven's Progressive Matrices problem from Wikipedia:<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Raven_Matrix.svg/1024px-Raven_Matrix.svg.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Raven_Matrix.svg/1024px-Raven_Matrix.svg.png" width="320" /></a></div><span id="goog_1111037341"></span>The patterns represented by these problems can range from addition or subtraction to rotation, scaling, inversion, repetition, and more. Furthermore, the patterns can be vertical, horizontal, diagonal, or some combination thereof. Clearly, they are not trivial, and there is no clear rule or heuristic that would solve any arbitrary problem.<br /><br />To tackle this problem, I used a combination of different methods. First, I enumerated various possible patterns and rules that could be represented in the tests. Each rule had a different complexity weight, where lower complexity is preferred over higher complexity. For instance, "fill" is preferable to "overlap", "size" is preferable to "above", and so on. Each rule relates to a single shape identified in the image, and how it relates to the next frame of the problem and the shapes around it.<br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">private class scoreAndComplexity{</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; public double score;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; public int complexity;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; public scoreAndComplexity(double score, int complexity){</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.score = score;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.complexity = complexity;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; }</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; private class rulesAndComplexity {</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; public int complexity;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; public HashMap&lt;String, String&gt; rules;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; public rulesAndComplexity(int complexity, HashMap&lt;String, String&gt; rules){</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.complexity = complexity;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.rules = rules;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">&nbsp; &nbsp; }</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span>After possible complexities and rules are established for a set of images, they are all scored against other available information. In a 3x3 matrix with a horizontal pattern, for example, the pattern can be validated against the second row before putting it into practice for the third row. This is done by generating a prediction based on the rules found above, and then comparing that prediction to what is really in the second row (or column, for vertical rules). High scoring rulesets are preferred to low scores, and ties are broken by complexity and number of rules.<br /><br />Rules are determined by analyzing 2d arrays of 1s and 0s which represent the input images. Images are converted to black and white, where black translates to a 1 and white to a 0. Various rules can be established immediately and lazily with just these arrays. Summation, subtraction, boolean operators, and scaling are all readily apparent by comparing one frame to the next. Other rules, like rotation, neighbor-dependent translation, fill, or inversion are more complicated and require case-specific rules.<br /><br />Overall, the problems are a lot of fun and very challenging to try to solve with a digital agent!<br /><br />