---
layout: post
title: Facial Expression Recognition with OpenCV 3+ and Python 3
date: '2016-11-09T09:28:00.000-05:00'
author: Andrew Silva
tags: 
modified_time: '2017-10-12T19:27:21.815-04:00'
thumbnail: https://1.bp.blogspot.com/-bN90akAw-Wo/WCMx1soxj2I/AAAAAAAAB74/nH-Y80wK4DM24Wcxz4evUhjJvcgkGWkZgCK4B/s72-c/Screen%2BShot%2B2016-11-09%2Bat%2B9.24.07%2BAM.png
blogger_id: tag:blogger.com,1999:blog-8622339093465720931.post-2948619390571821245
blogger_orig_url: http://www.andrew-silva.com/2016/11/facial-expression-recognition-with.html
---

Facial expressions are a very interesting problem for a variety of reasons. Of interest to me particularly is trying to mirror facial expressions in robotics, to make people more comfortable or to ease communication between humans and robots. As a starting point, if you want to train your own classifiers on the small dataset that my project references, you'll need to work with the Cohn and Kanade dataset, <a href="http://www.consortium.ri.cmu.edu/ckagree/">available here</a>. Similarly, the "giant dataset" that my code refers to is the fer2013.csv file that you can <a href="https://www.kaggle.com/c/challenges-in-representation-learning-facial-expression-recognition-challenge/data">download from Kaggle</a>. However, you can just use the models bundled up in my repo, which you can <a href="https://github.com/andrewsilva9/ExpressionRecognizer">pull down here</a>. In order to clean up the data, I followed and tweaked a tutorial <a href="http://www.paulvangent.com/2016/04/01/emotion-recognition-with-python-opencv-and-a-face-dataset/">over here</a>, but it isn't originally in OpenCV3 or Python3.<br /><br />The basic idea of the facial expression classifier I'm using is a boosted fisherface model. I trained 10 fisherface classifiers built into OpenCV on random subsets of the small dataset. At runtime, each incoming image is scanned for a face, scaled to be the same size as my small dataset images, and then run through all 10 of the classifiers. I take the mode of the 10 responses, and consider that to be the emotion represented by the incoming face.<br /><code style="display: block; white-space: pre-wrap;">def classify_emotion(self, input_image):     emotion_guesses = np.zeros((len(self.models), 1))     for index in range(len(self.models)):         prediction, confidence = self.models[index].predict(input_image)         emotion_guesses[index][0] = prediction     return int(stats.mode(emotion_guesses)[0][0]) </code><br /><br />As for the incoming images, you could supply them yourself. My code will turn on your webcam and use those, so that whoever is in front of the computer will be run through the recognizer in realtime. The performance is actually pretty decent as long as you're dedicating your face to the emotion, and not obscured somehow. Pulling in the webcam using OpenCV is actually very simple:<br /><br /><code style="display: block; white-space: pre-wrap;">capture = cv2.VideoCapture(0) while True:     ret, frame = capture.read()     gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)     face1 = self.face_finder.detectMultiScale(gray,&nbsp;</code><code style="display: block; white-space: pre-wrap;">                                              scaleFactor=1.1,&nbsp;</code><code style="display: block; white-space: pre-wrap;">                                              minNeighbors=10,&nbsp;</code><code style="display: block; white-space: pre-wrap;">                                              minSize=(5, 5),                                               flags=cv2.CASCADE_SCALE_IMAGE)</code><code style="display: block; white-space: pre-wrap;">    face2 = self.face_finder2.detectMultiScale(gray,</code><code style="display: block; white-space: pre-wrap;">                                               scaleFactor=1.1,</code><code style="display: block; white-space: pre-wrap;">                                               minNeighbors=10,</code><code style="display: block; white-space: pre-wrap;">                                               minSize=(5,5),                                                flags=cv2.CASCADE_SCALE_IMAGE)</code><code style="display: block; white-space: pre-wrap;">    face3 = self.face_finder3.detectMultiScale(gray,</code><code style="display: block; white-space: pre-wrap;">                                               scaleFactor=1.1,</code><code style="display: block; white-space: pre-wrap;">                                               minNeighbors=10,</code><code style="display: block; white-space: pre-wrap;">                                               minSize=(5, 5),                                                flags=cv2.CASCADE_SCALE_IMAGE)     face4 = self.face_finder4.detectMultiScale(gray,</code><code style="display: block; white-space: pre-wrap;">                                               scaleFactor=1.1,</code><code style="display: block; white-space: pre-wrap;">                                               minNeighbors=10,&nbsp;</code><code style="display: block; white-space: pre-wrap;">                                               minSize=(5, 5),</code><code style="display: block; white-space: pre-wrap;">                                               flags=cv2.CASCADE_SCALE_IMAGE)   # Go over detected faces, stop at first detected face, return empty if no face.     if len(face1) == 1:         face = face1[0]     elif len(face2) == 1:         face = face2[0]     elif len(face3) == 1:         face = face3[0]     elif len(face4) == 1:         face = face4[0]     else:         continue # Cut and save face # scale image     gray = gray[face[1]:face[1] + face[3],                 face[0]:face[0] + face[2]]     out = cv2.resize(gray, (self.image_height, self.image_width))     print(self.emotions[self.classifier.classify_emotion(out)]) </code><code style="display: block; white-space: pre-wrap;"><br /></code><br />If you're interested in working with the larger dataset, the files are all there. "train_bigger_emotion_classifier" will get you started by getting the data ready and showing how to train a linear SVM on it, but fair warning: it is hard to do well on that dataset. The winner of the Kaggle competition got something around 77% accuracy, working with a convolutional neural network (something my repo doesn't include).<br /><br />To run my project, simply throw all of the files into the same directory and run the "emotion_runner.py" file. It'll take a second to load up the models and set up the webcam, and then you'll start seeing classifications of your face!<br /><br /><a href="http://1.bp.blogspot.com/-bN90akAw-Wo/WCMx1soxj2I/AAAAAAAAB74/nH-Y80wK4DM24Wcxz4evUhjJvcgkGWkZgCK4B/s1600/Screen%2BShot%2B2016-11-09%2Bat%2B9.24.07%2BAM.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="https://1.bp.blogspot.com/-bN90akAw-Wo/WCMx1soxj2I/AAAAAAAAB74/nH-Y80wK4DM24Wcxz4evUhjJvcgkGWkZgCK4B/s640/Screen%2BShot%2B2016-11-09%2Bat%2B9.24.07%2BAM.png" width="100%" /></a><br /><br />Overall, performance isn't too terrible. For happy, neutral, angry, and surprised you can count on it to work pretty reliably. The other emotions in the small dataset (disgust, contempt, sadness, and fear) are tougher to get, presumably because they are very specific in the training data and hard to replicate naturally.<br /><br />Future work will involve trying to classify facial expressions without needing the mouth as much. If you want to reciprocate an expression while someone is speaking, you need to be able to capture that expression without their full face (since the mouth will be moving to speak). Obviously this is a bigger challenge, but certainly seems to be a more relevant problem.<br /><br />References:<br />[1]&nbsp;<span style="background-color: white; color: #2d2d2d; font-family: &quot;open sans&quot; , sans-serif; font-size: 14px;">van Gent, P. (2016). Emotion Recognition With Python, OpenCV and a Face Dataset.&nbsp;</span><em style="box-sizing: border-box; color: #2d2d2d; font-family: 'Open Sans', sans-serif; font-size: 14px;">A tech blog about fun things with Python and embedded electronics.</em><span style="background-color: white; color: #2d2d2d; font-family: &quot;open sans&quot; , sans-serif; font-size: 14px;">&nbsp;Retrieved from:</span><br /><span style="background-color: white; color: #2d2d2d; font-family: &quot;open sans&quot; , sans-serif; font-size: 14px;">http://www.paulvangent.com/2016/04/01/emotion-recognition-with-python-opencv-and-a-face-dataset/</span><br /><div><span style="background-color: white; color: #2d2d2d; font-family: &quot;open sans&quot; , sans-serif; font-size: 14px;">[2]&nbsp;</span><span style="background-color: white; color: #2d2d2d; font-family: &quot;open sans&quot; , sans-serif; font-size: 14px;">Kanade, T., Cohn, J. F., &amp; Tian, Y. (2000). Comprehensive database for facial expression analysis. Proceedings of the Fourth IEEE International Conference on Automatic Face and Gesture Recognition (FGâ€™00), Grenoble, France, 46-53.</span></div><span style="background-color: white; color: #2d2d2d; font-family: &quot;open sans&quot; , sans-serif; font-size: 14px;">[3] Lucey, P., Cohn, J. F., Kanade, T., Saragih, J., Ambadar, Z., &amp; Matthews, I. (2010). The Extended Cohn-Kanade Dataset (CK+): A complete expression dataset for action unit and emotion-specified expression. Proceedings of the Third International Workshop on CVPR for Human Communicative Behavior Analysis (CVPR4HB 2010), San Francisco, USA, 94-101.</span>